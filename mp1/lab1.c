/* lab1.c
 * Zice Wei                       <--- replace with your name!
 * zicew                              <--- replace with your user name!
 * ECE 2230 Fall 2018
 * MP1
 *
 * NOTE:  You must update all of the following comments!
 *
 * Purpose: A template for MP1 to record CBRS information using
 *          data structure and dynamic memory allocation.
 *
 * Assumptions: Many details are incomplete.  The functions to collect input
 * for a record and to print a record specify the format that is required for
 * grading.
 *
 * An outline for the interactive menu input is provided.  Details need to be
 * completed but format of the commands and the output generated by the
 * print statements must not be changed. You have to call the corrent
 * print statement in response to the input
 *
 * Bugs: no bugs.
 *
 * See the ECE 2230 programming guide
 *
 * NOTE: if it forbidden to access any of the members in the saslist_t
 * structure.   The members that start with sec_usrs followed by an underscore
 * MUST NOT be found in this file or it is a design violation.  Instead you
 * must utilize the saslist_ fuctions found in the saslist header file to
 * access any details of the list.
 *
 * One of the requirements is to verify you program does not have any
 * memory leaks or other errors that can be detected by valgrind.  Run with
 * your test script(s):
 *      valgrind --leak-check=full ./lab1 < your_test_script
 *
 * Are you unhappy with the way this code is formatted?  You can easily
 * reformat (and automatically indent) your code using the astyle
 * command.  If it is not installed use the Ubuntu Software Center to
 * install astyle.  Then in a terminal on the command line do
 *     astyle --style=kr lab1.c
 *
 * See "man astyle" for different styles.  Replace "kr" with one of
 * ansi, java, gnu, linux, or google to see different options.  Or, set up
 * your own style.
 *
 * To create a nicely formated PDF file for printing install the enscript
 * command.  To create a PDF for "file.c" in landscape with 2 columns do:
 *     enscript file.c -G2rE -o - | ps2pdf - file.pdf
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "saslist.h"

#define MAXLINE 256

// function prototypes for lab1.c
void fill_sec_usr_record(struct secusr_info_t *new);
void print_sec_usr_rec(struct secusr_info_t *rec);
int invalid_ch(int channel_num);


/*Purpose: main function of lab1. Contain user interface for this lab.
 *         possible command: CREATE X, ADDSU X, DELSU, CLEARSU, CLEARCH X,
 *         CHANGCH X, STATS, PRINT, QUIT.
 *there is no inputs. 
 *return 0 if programming runs correctly.
 *
 */
int main(int argc, char *argv[])
{
    char line[MAXLINE];
    char command[MAXLINE];
    char junk[MAXLINE];
    int list_size = -1;
    int num_items;
    int input_1, input_2;
    int i;
    struct secusr_info_t *rec_ptr = NULL;
    struct saslist_t *list_ptr = NULL;

    if (argc != 1) {
        printf("Usage: ./lab1\n");
        exit(1);
    }
    printf("Welcome to lab1. Possible commands:\n");
    printf("CREATE x\nADDSU\nLISTCH x\nDELSU x\nCLEARCH x\n");
    printf("CHANGECH old new\nSTATS\nPRINT\nQUIT\n");

    // remember fgets includes newline \n unless line too long
    while (fgets(line, MAXLINE, stdin) != NULL) {
        num_items = sscanf(line, "%s%d%d%s", command, &input_1, &input_2, junk);
        if (num_items == 2 && strcmp(command, "CREATE") == 0) {
            list_size = input_1;
            if (list_size < 1) {
                printf("Cannot create list: invalid size %d\n", list_size);
            } else {
                // clean up old list if necessary and create a new empty one
                if (list_ptr != NULL) {
                    saslist_destruct(list_ptr);
                }
                list_ptr = saslist_construct(list_size);

                printf("New list with size: %d\n", list_size);
            }
        } else if (num_items == 1 && strcmp(command, "QUIT") == 0) {
            saslist_destruct(list_ptr);
            list_ptr = NULL;
            printf("Goodbye\n");
            break;
        } else if (num_items == 1 && strcmp(command, "ADDSU") == 0) {
            rec_ptr = (struct secusr_info_t *) malloc(sizeof(struct secusr_info_t));
            fill_sec_usr_record(rec_ptr);

            // you have to figure out what goes here
            // and call the correct printf command
            int added_return = -2;
            added_return = saslist_add(list_ptr, rec_ptr);

            if (added_return == 1) {
                printf("Inserted: %d\n", rec_ptr->su_id);
            } else if (added_return == 0) {
                printf("Updated: %d\n", rec_ptr->su_id);
            } else if (added_return == -1) {
                printf("Rejected: %d\n", rec_ptr->su_id);
                free(rec_ptr);
                rec_ptr = NULL;
            } else {
                printf("Error with return value! Fix your code.\n");
            }
            rec_ptr = NULL;
        } else if (num_items == 2 && strcmp(command, "LISTCH") == 0) {
            int num_in_list = saslist_number_entries(list_ptr);
            if (invalid_ch(input_1)) {
                printf("Invalid channel number %d for LISTCH\n", input_1);
            } else if (num_in_list == 0) {
                printf("List empty no users on ch %d\n", input_1);
            } else {
                printf("List has %d records.  Looking for ch %d\n",
                       num_in_list, input_1);
                // print record of each user on channel
                for (i = 0; i < num_in_list; i++) {
                    rec_ptr = saslist_access(list_ptr, i);  
                    if(rec_ptr->channel == input_1) {
                        print_sec_usr_rec(rec_ptr);
                    }
                }
            }
            rec_ptr = NULL;
        } else if (num_items == 2 && strcmp(command, "DELSU") == 0) {
            int lookup_val=-2;
            lookup_val = saslist_lookup(list_ptr, input_1);
            //no such su_id.
            if(lookup_val == -1) {
                rec_ptr = NULL;
            } else {
                rec_ptr = saslist_remove(list_ptr, lookup_val);
            }
            if (rec_ptr == NULL) {
                printf("Did not remove: %d\n", input_1);
            } else {
                printf("Removed: %d\n", input_1);
                print_sec_usr_rec(rec_ptr);
                free(rec_ptr);
            }
            rec_ptr = NULL;

        } else if (num_items == 2 && strcmp(command, "CLEARCH") == 0) {
            int count_removed = 0;

            // remove records on matching channel.  After done print
            // message about number removed
            if (invalid_ch(input_1)) {
                printf("Invalid channel number %d for CLEARCH\n", input_1);
            } else {
                for (i = 0; i < saslist_number_entries(list_ptr); i++) {
                    rec_ptr = saslist_access(list_ptr, i);
                    if(rec_ptr->channel == input_1) {
                        count_removed++;
                        rec_ptr = saslist_remove(list_ptr, i);
                        free(rec_ptr);
                        rec_ptr = NULL;
                        i--;
                    }
                }

                if (count_removed == 0) {
                    printf("Did not find any users on channel %d\n", input_1);
                } else {
                    printf("Removed %d from channel %d\n", count_removed, input_1);
                }
            }
            rec_ptr = NULL;
        } else if (num_items == 3 && strcmp(command, "CHANGECH") == 0) {
            int count_moved = 0;
            if (invalid_ch(input_1) || invalid_ch(input_2)) {
                printf("Invalid old %d or new %d channel for CHANGECH\n",
                       input_1, input_2);
            } else {
                // move records on channel input_1 to channel input_2.
                // After done print message about number moved
                for (i = 0; i < saslist_number_entries(list_ptr); i++) {
                    rec_ptr = saslist_access(list_ptr, i);
                    if(rec_ptr->channel == input_1) {
                        rec_ptr->channel = input_2;
                        rec_ptr = NULL;
                        count_moved++;
                    }
                }
                if (count_moved == 0) {
                    printf("Did not find any users on channel %d\n", input_1);
                } else {
                    printf("Moved %d users from channel %d to %d\n", count_moved,
                           input_1, input_2);
                }
            }
            rec_ptr = NULL;
        } else if (num_items == 1 && strcmp(command, "STATS") == 0) {
            // get the number in list and size of the list
            int num_in_list = saslist_number_entries(list_ptr);
            int size_of_list = saslist_arraysize(list_ptr);
            printf("Number records: %d, Array size: %d\n",
                   num_in_list, size_of_list);
        } else if (num_items == 1 && strcmp(command, "PRINT") == 0) {
            int num_in_list = saslist_number_entries(list_ptr);
            if (num_in_list == 0) {
                printf("List empty\n");
            } else {
                printf("List has %d records\n", num_in_list);
                for (i = 0; i < num_in_list; i++) {
                    printf("%d: ", i+1);
                    rec_ptr = saslist_access(list_ptr, i);
                    print_sec_usr_rec(rec_ptr);
                }
            }
            rec_ptr = NULL;
        } else {
            printf("# %s", line);
        }
    }
    exit(0);
}

/* Checks for a invalid channel number.  Channel numbers must be 1:10
 *
 * returns true if invalild channel
 *         false if valid channel
 */
int invalid_ch(int channel_num)
{
    if (channel_num < 1 || channel_num > 10) return 1;
    return 0;
}

/* Prompts user for secondary user record input starting with the ID number
 * assigned to the secondary uers by the SAS.
 * The input is not checked for errors but will default to an acceptable value
 * if the input is incorrect or missing.
 *
 * The input to the function assumes that the structure has already been
 * created.  The contents of the structure are filled in.
 *
 * There is no output.
 *
 * DO NOT CHANGE THIS FUNCTION!
 */
void fill_sec_usr_record(struct secusr_info_t *new)
{
    char line[MAXLINE];
    char str[MAXLINE];
    assert(new != NULL);

    printf("secondary user ID number:");
    fgets(line, MAXLINE, stdin);
    sscanf(line, "%d", &new->su_id);
    printf("IP address:");
    fgets(line, MAXLINE, stdin);
    sscanf(line, "%d", &new->ip_address);
    printf("Access point IP address:");
    fgets(line, MAXLINE, stdin);
    sscanf(line, "%d", &new->access_point);

    printf("Authenticated (T/F):");
    fgets(line, MAXLINE, stdin);
    sscanf(line, "%s", str);
    if (strcmp(str, "T")==0 || strcmp(str, "t")==0)
        new->authenticated = 1;
    else
        new->authenticated = 0;

    printf("Privacy (none|standard|strong|NSA):");
    fgets(line, MAXLINE, stdin);
    sscanf(line, "%s", str);
    if (strcmp(str, "standard")==0)
        new->privacy = 1;
    else if (strcmp(str, "strong")==0)
        new->privacy = 2;
    else if (strcmp(str, "NSA")==0)
        new->privacy = 3;
    else
        new->privacy = 0;


    printf("Band (2.4|3.5|5.0):");
    fgets(line, MAXLINE, stdin);
    sscanf(line, "%f", &new->band);

    printf("Channel:");
    fgets(line, MAXLINE, stdin);
    sscanf(line, "%d", &new->channel);

    printf("Data rate:");
    fgets(line, MAXLINE, stdin);
    sscanf(line, "%f", &new->data_rate);

    printf("Time received (int):");
    fgets(line, MAXLINE, stdin);
    sscanf(line, "%d", &new->time_received);
    printf("\n");
}

/* print the information for a particular secondary user record
 *
 * Input is a pointer to a record, and no entries are changed.
 * No return val.
 *
 * DO NOT CHANGE THIS FUNCTION!
 */
void print_sec_usr_rec(struct secusr_info_t *rec)
{
    const char *pri_str[] = {"none", "standard", "strong", "NSA"};
    assert(rec != NULL);
    printf("ID: %d,", rec->su_id);
    printf(" MIP: %d, AID: %d,", rec->ip_address,
           rec->access_point);
    printf(" Auth: %s,", rec->authenticated ? "T" : "F");
    printf(" Pri: %s, B: %g, C: %d,", pri_str[rec->privacy],
           rec->band, rec->channel);
    printf(" R: %g", rec->data_rate);
    printf(" Time: %d\n", rec->time_received);
}


/* commands specified to vim. ts: tabstop, sts: soft tabstop sw: shiftwidth */
/* vi:set ts=8 sts=4 sw=4 et: */
